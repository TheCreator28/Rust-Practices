// Practica 34: Enums con datos y patrones
// Objetivo: Dise√±ar enums ricos y hacer pattern matching.

fn main() {
    // Paso 1: Define un enum `Respuesta` con variantes `Exito(i32)`, `Error(String)` y `Pendiente`.
    // Paso 2: Crea una funcion que devuelva `Respuesta` segun un valor de entrada.
    // Paso 3: Usa `match` para manejar cada caso y mostrar mensajes distintos.
    // Paso 4: Explica en comentarios como los enums modelan estados mutuamente excluyentes.

    // Escribe tu solucion aqui siguiendo los pasos anteriores.
}
